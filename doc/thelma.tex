% generated by GAPDoc2LaTeX from XML source (Frank Luebeck)
\documentclass[a4paper,11pt]{report}

\usepackage{a4wide}
\sloppy
\pagestyle{myheadings}
\usepackage{amssymb}
\usepackage[latin1]{inputenc}
\usepackage{makeidx}
\makeindex
\usepackage{color}
\definecolor{FireBrick}{rgb}{0.5812,0.0074,0.0083}
\definecolor{RoyalBlue}{rgb}{0.0236,0.0894,0.6179}
\definecolor{RoyalGreen}{rgb}{0.0236,0.6179,0.0894}
\definecolor{RoyalRed}{rgb}{0.6179,0.0236,0.0894}
\definecolor{LightBlue}{rgb}{0.8544,0.9511,1.0000}
\definecolor{Black}{rgb}{0.0,0.0,0.0}

\definecolor{linkColor}{rgb}{0.0,0.0,0.554}
\definecolor{citeColor}{rgb}{0.0,0.0,0.554}
\definecolor{fileColor}{rgb}{0.0,0.0,0.554}
\definecolor{urlColor}{rgb}{0.0,0.0,0.554}
\definecolor{promptColor}{rgb}{0.0,0.0,0.589}
\definecolor{brkpromptColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapinputColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapoutputColor}{rgb}{0.0,0.0,0.0}

%%  for a long time these were red and blue by default,
%%  now black, but keep variables to overwrite
\definecolor{FuncColor}{rgb}{0.0,0.0,0.0}
%% strange name because of pdflatex bug:
\definecolor{Chapter }{rgb}{0.0,0.0,0.0}
\definecolor{DarkOlive}{rgb}{0.1047,0.2412,0.0064}


\usepackage{fancyvrb}

\usepackage{mathptmx,helvet}
\usepackage[T1]{fontenc}
\usepackage{textcomp}


\usepackage[
            pdftex=true,
            bookmarks=true,        
            a4paper=true,
            pdftitle={Written with GAPDoc},
            pdfcreator={LaTeX with hyperref package / GAPDoc},
            colorlinks=true,
            backref=page,
            breaklinks=true,
            linkcolor=linkColor,
            citecolor=citeColor,
            filecolor=fileColor,
            urlcolor=urlColor,
            pdfpagemode={UseNone}, 
           ]{hyperref}

\newcommand{\maintitlesize}{\fontsize{50}{55}\selectfont}

% write page numbers to a .pnr log file for online help
\newwrite\pagenrlog
\immediate\openout\pagenrlog =\jobname.pnr
\immediate\write\pagenrlog{PAGENRS := [}
\newcommand{\logpage}[1]{\protect\write\pagenrlog{#1, \thepage,}}
%% were never documented, give conflicts with some additional packages

\newcommand{\GAP}{\textsf{GAP}}

%% nicer description environments, allows long labels
\usepackage{enumitem}
\setdescription{style=nextline}

%% depth of toc
\setcounter{tocdepth}{1}





%% command for ColorPrompt style examples
\newcommand{\gapprompt}[1]{\color{promptColor}{\bfseries #1}}
\newcommand{\gapbrkprompt}[1]{\color{brkpromptColor}{\bfseries #1}}
\newcommand{\gapinput}[1]{\color{gapinputColor}{#1}}


\begin{document}

\logpage{[ 0, 0, 0 ]}
\begin{titlepage}
\mbox{}\vfill

\begin{center}{\maintitlesize \textbf{ GAP 4 Package Thelma \mbox{}}}\\
\vfill

\hypersetup{pdftitle= GAP 4 Package Thelma }
\markright{\scriptsize \mbox{}\hfill  GAP 4 Package Thelma  \hfill\mbox{}}
{\Huge \textbf{ THreshold ELements, Modeling and Applications \mbox{}}}\\
\vfill

{\Huge  1.0.0 \mbox{}}\\[1cm]
{ 2018 \mbox{}}\\[1cm]
\mbox{}\\[2cm]
{\Large \textbf{ Victor Bovdi\\
   \mbox{}}}\\
{\Large \textbf{ Vasyl Laver\\
   \mbox{}}}\\
\hypersetup{pdfauthor= Victor Bovdi\\
   ;  Vasyl Laver\\
   }
\end{center}\vfill

\mbox{}\\
{\mbox{}\\
\small \noindent \textbf{ Victor Bovdi\\
   }  Email: \href{mailto://vbovdi@gmail.com} {\texttt{vbovdi@gmail.com}}\\
  Address: \begin{minipage}[t]{8cm}\noindent
 Department of Mathematical Sciences\\
 UAEU\\
 Al Ain, United Arab Emirates\\
 \end{minipage}
}\\
{\mbox{}\\
\small \noindent \textbf{ Vasyl Laver\\
   }  Email: \href{mailto://vasyl.laver@uzhnu.edu.ua} {\texttt{vasyl.laver@uzhnu.edu.ua}}\\
  Address: \begin{minipage}[t]{8cm}\noindent
 Department of Mathematical Sciences\\
 UAEU\\
 Al Ain, United Arab Emirates\\
 \end{minipage}
}\\
\end{titlepage}

\newpage\setcounter{page}{2}
{\small 
\section*{Copyright}
\logpage{[ 0, 0, 1 ]}
 {\copyright} 2018 by the authors

 This package may be distributed under the terms and conditions of the GNU
Public License Version 2 or higher. \mbox{}}\\[1cm]
\newpage

\def\contentsname{Contents\logpage{[ 0, 0, 2 ]}}

\tableofcontents
\newpage

  
\chapter{\textcolor{Chapter }{Introduction}}\label{intro}
\logpage{[ 1, 0, 0 ]}
\hyperdef{L}{X7DFB63A97E67C0A1}{}
{
  \textsf{Thelma} stands for ``THreshold ELements, Modelling and Applications". This package is
dedicated to realization of Boolean functions by the means of the threshold
elements and multilayered perceptrons. Threshold elements were introduced in \cite{McCulloch43a}. A certain number of articles on threshold logic appeared in 60-s and 70-s,
however this field is regaining a considerable interest nowadays as well (see \cite{Horvath16},\cite{Horvath1994}, \cite{Gowda11}, \cite{Kulkarni16}, e.t.c). 

 We mostly refer to the methods proposed in \cite{GecheBovdi80}, \cite{GecheRobotyshyn83}, \cite{GecheMulesa2017}, and \cite{Dertouzos65}. 
\section{\textcolor{Chapter }{Overview over this manual}}\label{overview}
\logpage{[ 1, 1, 0 ]}
\hyperdef{L}{X786BACDB82918A65}{}
{
  Chapter \ref{thr_elements} describes the functions operating with the threshold elements. They include
the basic operations, the functions that verify the realizability of a given
Boolean function by a single threshold element, and some iterative methods.
Chapter \ref{thr_networks} describes the functions for neural networks, built from the threshold
elements. }

 
\section{\textcolor{Chapter }{Installation}}\label{instal}
\logpage{[ 1, 2, 0 ]}
\hyperdef{L}{X8360C04082558A12}{}
{
  To get the newest version of this \textsf{GAP} 4 package download one of the archive files 
\begin{itemize}
\item  \texttt{thelma-x.x.tar.gz} 
\item  \texttt{thelma-x.x.tar.bz2} 
\item  \texttt{thelma-x.x.zip} 
\end{itemize}
 and unpack it using 
\begin{verbatim}  
  gunzip thelma-x.x.tar.gz; tar xvf thelma-x.x.tar
\end{verbatim}
 or 
\begin{verbatim}  
  bzip2 -d thelma-x.x.tar.bz2; tar xvf thelma-x.x.tar
\end{verbatim}
 or 
\begin{verbatim}  
  unzip -x thelma-x.x.zip
\end{verbatim}
 respectively. 

 Do this in a directory called ``\texttt{pkg}'', preferably (but not necessarily) in the ``\texttt{pkg}'' subdirectory of your \textsf{GAP} 4 installation. It creates a subdirectory called ``\texttt{thelma}''.

 As \textsf{Thelma} has no additional C libraries, there is no need in any additional installation
steps.

 }

 
\section{\textcolor{Chapter }{Feedback}}\label{feedback}
\logpage{[ 1, 3, 0 ]}
\hyperdef{L}{X80D704CC7EBFDF7A}{}
{
  For bug reports, feature requests and suggestions, please write us an e-mail. }

  }

   
\chapter{\textcolor{Chapter }{Threshold Elements}}\label{thr_elements}
\logpage{[ 2, 0, 0 ]}
\hyperdef{L}{X83DFEF607CDA3594}{}
{
  
\section{\textcolor{Chapter }{Basic Operations}}\label{thr_basic}
\logpage{[ 2, 1, 0 ]}
\hyperdef{L}{X82EB5BE77F9F686A}{}
{
  For a given real vector $w=(w_1, \ldots, w_n) \in {\mathbb{R}}^n$ and a threshold $T \in \mathbb{R}$, the \mbox{\texttt{\mdseries\slshape threshold element}} is a function $f: \mathbb{Z}_2^n \to \mathbb{Z}_2$ defined by the following relations: 
\[ f(x_1,\dots,x_n) = 1, \quad \textrm{if} \quad \sum_{i = 1}^{n} w_i x_i \geq T,
\quad \textrm{and} \quad f(x_1,\dots,x_n) = 0 \quad \textrm{otherwise}, \]
 in which $f(x_1,\dots,x_n)$ is the binary output (valued 0 or 1), each variable $x_i$ is the i-th input (valued 0 or 1), and $n$ is the number of inputs. 

 The vector $w$ is the \mbox{\texttt{\mdseries\slshape weight}} vector, and the $x=(x_1, \ldots, x_n)$ is the \mbox{\texttt{\mdseries\slshape input}} vector. The vector $(w_1, \ldots, w_n;T)$ is called the \mbox{\texttt{\mdseries\slshape structure vector}} (or simply the \mbox{\texttt{\mdseries\slshape structure}}) of the threshold element. 

\subsection{\textcolor{Chapter }{ThresholdElement}}
\logpage{[ 2, 1, 1 ]}\nobreak
\hyperdef{L}{X853FF8AC85E5C4CE}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{ThresholdElement({\mdseries\slshape Weights, Threshold})\index{ThresholdElement@\texttt{ThresholdElement}}
\label{ThresholdElement}
}\hfill{\scriptsize (function)}}\\


  For the list of rational numbers \texttt{Weights} and the rational \texttt{Threshold} the function \texttt{ThresholdElement} returns a threshold element with the number of inputs equal to the length of
the \texttt{Weights} list. 
\begin{Verbatim}[commandchars=!@A,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>A !gapinput@te:=ThresholdElement([1,2],3);A
  < threshold element with weight vector [ 1, 2 ] and threshold 3 >
  !gapprompt@gap>A !gapinput@Display(te);A
  Weight vector = [ 1, 2 ], Threshold = 3.
  Threshold Element realizes the function f :
  [ 0, 0 ] || 0
  [ 0, 1 ] || 0
  [ 1, 0 ] || 0
  [ 1, 1 ] || 1
  Sum of Products:[ 3 ]
  
\end{Verbatim}
 The function \texttt{Display} outputs the stucture of the given threshold element \texttt{ThrEl} and the Sum of Products or Product of Sums representation of the function
realized by \texttt{ThrEl}. For threshold elements of $n \leq 4$ variables it also prints the truth table of the realized Boolean function. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@w:=[1,2,4,-4,6,8,10,-25,6,32];;|
  !gapprompt@gap>| !gapinput@T:=60;;|
  !gapprompt@gap>| !gapinput@te:=ThresholdElement(w,T);|
  < threshold element with weight vector [ 1, 2, 4, -4, 6, 8, 10, -25, 6, 32
   ] and threshold 60 >
  !gapprompt@gap>| !gapinput@Display(te);|
  Weight vector = [ 1, 2, 4, -4, 6, 8, 10, -25, 6, 32 ], Threshold = 60.
  Threshold Element realizes the function f :
  Sum of Products:[ 59, 155, 185, 187, 251, 315, 379, 411, 427, 441, 443, 507, 5\
  71, 667, 697, 699, 763, 827, 891, 923, 939, 953, 955, 1019 ]
  
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{IsThresholdElement}}
\logpage{[ 2, 1, 2 ]}\nobreak
\hyperdef{L}{X7E7F95D57EB87BB4}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{IsThresholdElement({\mdseries\slshape Obj})\index{IsThresholdElement@\texttt{IsThresholdElement}}
\label{IsThresholdElement}
}\hfill{\scriptsize (function)}}\\


  For the object \texttt{Obj} the function \texttt{IsThresholdElement} returns \texttt{true} if \texttt{Obj} is a threshold element (see \texttt{ThresholdElement} (\ref{ThresholdElement})), and \texttt{false} otherwise. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@te:=ThresholdElement([1,2],3);|
  < threshold element with weight vector [ 1, 2 ] and threshold 3 >
  !gapprompt@gap>| !gapinput@IsThresholdElement(te);|
  true
  !gapprompt@gap>| !gapinput@IsThresholdElement([[1,2],3]);|
  false
  
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{OutputOfThresholdElement}}
\logpage{[ 2, 1, 3 ]}\nobreak
\hyperdef{L}{X7F293D2D810ADBBB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{OutputOfThresholdElement({\mdseries\slshape ThrEl})\index{OutputOfThresholdElement@\texttt{OutputOfThresholdElement}}
\label{OutputOfThresholdElement}
}\hfill{\scriptsize (function)}}\\


  Let $f: \mathbb{Z}_2^n \to \mathbb{Z}_2$ be a Boolean function. The vector 
\[ F=(\;f(0),\; f(1),\; \ldots,\; f(2^n-1)\;)^T, \]
 where $f(i)$ for each $i \in \{0,1,\ldots,2^n-1\}$ is the value of $f(x_1,\ldots,x_n)$ of the i-th row in the truth table, is called the \mbox{\texttt{\mdseries\slshape truth vector}}.

 For the threshold element \texttt{ThrEl} the function \texttt{OutputOfThresholdElement} returns the truth vector of the Boolean function, realized by \texttt{ThrEl}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@te:=ThresholdElement([1,2],3);|
  < threshold element with weight vector [ 1, 2 ] and threshold 3 >
  !gapprompt@gap>| !gapinput@f:=OutputOfThresholdElement(te);|
  [ 0, 0, 0, 1 ]
  
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{StructureOfThresholdElement}}
\logpage{[ 2, 1, 4 ]}\nobreak
\hyperdef{L}{X8116985278C60D33}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{StructureOfThresholdElement({\mdseries\slshape ThrEl})\index{StructureOfThresholdElement@\texttt{StructureOfThresholdElement}}
\label{StructureOfThresholdElement}
}\hfill{\scriptsize (function)}}\\


  For the threshold element \texttt{ThrEl} the function \texttt{StructureOfThresholdElement} returns a structure vector [\texttt{Weights},\texttt{Threshold}] (see \texttt{ThresholdElement} (\ref{ThresholdElement})). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@te:=ThresholdElement([1,2],3);|
  < threshold element with weight vector [ 1, 2 ] and threshold 3 >
  !gapprompt@gap>| !gapinput@sv:=StructureOfThresholdElement(te);|
  [ [ 1, 2 ], 3 ]
  
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{RandomThresholdElement}}
\logpage{[ 2, 1, 5 ]}\nobreak
\hyperdef{L}{X800C6898856CD0E9}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{RandomThresholdElement({\mdseries\slshape NumVar, Lo, Hi})\index{RandomThresholdElement@\texttt{RandomThresholdElement}}
\label{RandomThresholdElement}
}\hfill{\scriptsize (function)}}\\


  For the integers \texttt{NumVar}, \texttt{Lo}, and \texttt{Hi}, the function \texttt{RandomThresholdElement} returns a threshold element of \texttt{NumVar} variables with a pseudo random integer weight vector and an integer threshold,
where both the weights and the threshold are chosen from the interval [\texttt{Lo}, \texttt{Hi}]. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@te:=RandomThresholdElement(4,-10,10);|
  < threshold element with weight vector [ 7, -8, -6, 10 ] and threshold 2 >
  
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{Comparison of Threshold Elements}}
\logpage{[ 2, 1, 6 ]}\nobreak
\hyperdef{L}{X7C9E64E17B07DF58}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{Comparison of Threshold Elements({\mdseries\slshape ThrEl1, ThrEl2})\index{Comparison of Threshold Elements@\texttt{Comparison of Threshold Elements}}
\label{Comparison of Threshold Elements}
}\hfill{\scriptsize (function)}}\\


  Let \texttt{ThrEl1} and \texttt{ThrEl2} be two threshold elements of the same number of variables, which realize the
following Boolean functions (see \texttt{ThresholdElement} (\ref{ThresholdElement})) $f_1$ and $f_2$, resprectively. By comparison of two threshold elements we mean the
comparison of the truth vectors of $f_1$ and $f_2$ (see \texttt{OutputOfThresholdElement} (\ref{OutputOfThresholdElement})). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@te1:=ThresholdElement([1,2],3);;|
  !gapprompt@gap>| !gapinput@List(OutputOfThresholdElement(te1),Order);|
  [ 0, 0, 0, 1 ]
  !gapprompt@gap>| !gapinput@te2:=ThresholdElement([1,2],0);;|
  !gapprompt@gap>| !gapinput@List(OutputOfThresholdElement(te2),Order);|
  [ 1, 1, 1, 1 ]
  !gapprompt@gap>| !gapinput@te3:=ThresholdElement([1,1],2);;|
  !gapprompt@gap>| !gapinput@List(OutputOfThresholdElement(te3),Order);|
  [ 0, 0, 0, 1 ]
  !gapprompt@gap>| !gapinput@te1<te2;|
  true
  !gapprompt@gap>| !gapinput@te1>te2;|
  false
  !gapprompt@gap>| !gapinput@te1=te3;|
  true
  
\end{Verbatim}
 }

 }

 
\section{\textcolor{Chapter }{Single Threshold Element Realizability}}\label{ste_real}
\logpage{[ 2, 2, 0 ]}
\hyperdef{L}{X7DB8E3E87D8AD820}{}
{
  One of the most important questions is whether a Boolean function can be
realized by a single threshold element (STE). A Boolean function which is
realizable by a STE is called a \texttt{Threshold Function}. This section is dedicated to verification of STE-realizability.

 In \textsf{Thelma} package the user is allowed to input the Boolean functions in the following
forms: 

 (i) as a truth vector over $GF(2)$ (see \texttt{OutputOfThresholdElement} (\ref{OutputOfThresholdElement})); 

 (ii) as a string, representing the truth vector of the given Boolean function; 

 (iii) as a polynomial over $GF(2)$. 

 In the case (iii) we also need to enter the number of variables of $f$ (for example if $f(x,y)=x$, then $n=2$). 

 

\subsection{\textcolor{Chapter }{CharacteristicVectorOfFunction}}
\logpage{[ 2, 2, 1 ]}\nobreak
\hyperdef{L}{X8351E15B7CCDEB62}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{CharacteristicVectorOfFunction({\mdseries\slshape Func})\index{CharacteristicVectorOfFunction@\texttt{CharacteristicVectorOfFunction}}
\label{CharacteristicVectorOfFunction}
}\hfill{\scriptsize (function)}}\\


  Let $f(x_1,\ldots,x_n)$ be a Boolean function. We can switch from the
\texttt{\symbol{123}}0,1\texttt{\symbol{125}}-base to
\texttt{\symbol{123}}-1,1\texttt{\symbol{125}}-base using the following
transformation: 
\[ y_i = 2x_i-1, \quad (i = 1,2,\ldots,n) \]
 
\[ g(y_1,\ldots,y_n) = 2f(x_1,\ldots,x_n)-1. \]
 For each $i \in \{1,2,\ldots,n\}$ the $i$-th column of the truth table of the function $g(y_1,\ldots,y_n)$ (in \texttt{\symbol{123}}-1,1\texttt{\symbol{125}}-base) we denote by $Y_i$, and the truth vector of $g$ we denote by $G$.

 Define the following vector: 
\[ b = \big(\;Y_1 \cdot G,\; \ldots, \; Y_n \cdot G, \; \textstyle
\sum_{i=0}^{2^n-1} g(i) \; \big) \in \mathbb{R}^{n+1}, \]
 where $Y_k \cdot G$ is the classical inner (scalar) product for each $k \in \{1,\ldots,n\}$. 

 Vector $b$ is called the \mbox{\texttt{\mdseries\slshape characteristic vector}} of the Boolean function $f$ \cite{Dertouzos65}. Comparing the characteristic vector of the function $f$ with the lists of characteristic vectors of all STE-realizable functions we
obtain the answer wheter $f$ is realizable by STE or not. In \textsf{Thelma} package we have a database of all such vectors for STE-realizable functions of $n \leq 6$ variables obtained from \cite{Dertouzos65}. For the Boolean function \texttt{Func} the function \texttt{CharacteristicVectorOfFunction} returns a characteristic vector. There are no limitations on the cardinality
of \texttt{Func}, but the database of STE-realizable functions is given only for $n \leq 6$ variables. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@f:=[0*Z(2),0*Z(2),0*Z(2),Z(2)^0];|
  [ 0, 0, 0, 1 ]
  !gapprompt@gap>| !gapinput@c:=CharacteristicVectorOfFunction(f);|
  [ 2, 2, 2 ]
  !gapprompt@gap>| !gapinput@f:="0001";|
  "0001"
  !gapprompt@gap>| !gapinput@c:=CharacteristicVectorOfFunction(f);|
  [ 2, 2, 2 ]
  !gapprompt@gap>| !gapinput@x:=Indeterminate(GF(2),"x");|
  x
  !gapprompt@gap>| !gapinput@y:=Indeterminate(GF(2),"y");|
  y
  !gapprompt@gap>| !gapinput@f:=x+y;|
  x+y
  !gapprompt@gap>| !gapinput@c:=CharacteristicVectorOfFunction(f);|
  Enter the number of variables (n>=2):
  2
  [ 0, 0, 0 ]
  
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{IsCharacteristicVectorOfSTE}}
\logpage{[ 2, 2, 2 ]}\nobreak
\hyperdef{L}{X8502A0827ECF1FFE}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{IsCharacteristicVectorOfSTE({\mdseries\slshape ChVect})\index{IsCharacteristicVectorOfSTE@\texttt{IsCharacteristicVectorOfSTE}}
\label{IsCharacteristicVectorOfSTE}
}\hfill{\scriptsize (function)}}\\


  For the characteristic vector \texttt{ChVect} (see \texttt{CharacteristicVectorOfFunction} (\ref{CharacteristicVectorOfFunction})) the function \texttt{IsCharacteristicVectorOfSTE} returns \texttt{true} if \texttt{ChVect} is a characteristic vector of some STE-realizable Boolean function, and \texttt{false} otherwise. Note, that this function is implemented only for characteristic
vectors of length not bigger than 7. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@f:=x*y;|
  x*y
  !gapprompt@gap>| !gapinput@c:=CharacteristicVectorOfFunction(f);|
  Enter the number of variables (n>=2):
  [ 2, 2, 2 ]
  !gapprompt@gap>| !gapinput@IsCharacteristicVectorOfSTE(c);|
  true
  !gapprompt@gap>| !gapinput@f:=x+y;|
  x+y
  !gapprompt@gap>| !gapinput@c:=CharacteristicVectorOfFunction(f);|
  Enter the number of variables (n>=2):
  2
  [ 0, 0, 0 ]
  !gapprompt@gap>| !gapinput@IsCharacteristicVectorOfSTE(c);|
  false
  
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{IsUnateInVariable}}
\logpage{[ 2, 2, 3 ]}\nobreak
\hyperdef{L}{X78B9DD8E81EE65A8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{IsUnateInVariable({\mdseries\slshape Func, Var})\index{IsUnateInVariable@\texttt{IsUnateInVariable}}
\label{IsUnateInVariable}
}\hfill{\scriptsize (function)}}\\


  A Boolean function $f(x_1,\ldots ,x_n)$ is \mbox{\texttt{\mdseries\slshape positive unate}} in $x_{i}$ if for all possible values of $x_{j}$ with $j\neq i$ we have 
\[ f(x_{1},\ldots ,x_{i-1},1,x_{i+1},\ldots ,x_{n})\geq f(x_{1},\ldots
,x_{i-1},0,x_{i+1},\ldots ,x_{n}). \]
 A Boolean function $f(x_1,\ldots ,x_n)$ is \mbox{\texttt{\mdseries\slshape negative unate}} in $x_{i}$ if 
\[ f(x_{1},\ldots ,x_{i-1},0,x_{i+1},\ldots ,x_{n})\geq f(x_{1},\ldots
,x_{i-1},1,x_{i+1},\ldots ,x_{n}). \]
 For the Boolean function \texttt{Func} and the positive integer \texttt{Var} (which represents the number of the variable) the function \texttt{IsUnateBooleanFunction} returns \texttt{true} if \texttt{Func} is unate (either positive or negative) in this variable and \texttt{false} otherwise. 
\begin{Verbatim}[commandchars=!@A,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>A !gapinput@f:=[0*Z(2),0*Z(2),0*Z(2),0*Z(2),0*Z(2),Z(2)^0,Z(2)^0,0*Z(2)];A
  [ 0, 0, 0, 0, 0, 1, 1, 0 ]
  !gapprompt@gap>A !gapinput@nn:=BooleanFunctionByNeuralNetwork(f);;A
  !gapprompt@gap>A !gapinput@Display(nn);A
  Inner Layer:
  [ [[ 1, -2, 3 ], 4], [[ 1, 2, -3 ], 3] ]
  Outer Layer: disjunction
  Neural Network realizes the function f :
  [ 0, 0, 0 ] || 0
  [ 0, 0, 1 ] || 0
  [ 0, 1, 0 ] || 0
  [ 0, 1, 1 ] || 0
  [ 1, 0, 0 ] || 0
  [ 1, 0, 1 ] || 1
  [ 1, 1, 0 ] || 1
  [ 1, 1, 1 ] || 0
  Sum of Products:[ 5, 6 ]
  !gapprompt@gap>A !gapinput@IsUnateInVariable(f,1);A
  true
  !gapprompt@gap>A !gapinput@f:="00000110";A
  "00000110"
  !gapprompt@gap>A !gapinput@IsUnateInVariable(f,2);A
  false
  !gapprompt@gap>A !gapinput@f:=x*y+x*z;A
  x*y+x*z
  !gapprompt@gap>A !gapinput@IsUnateInVariable(f,3);A
  Enter the number of variables (n>=3):
  false
  
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{IsUnateBooleanFunction}}
\logpage{[ 2, 2, 4 ]}\nobreak
\hyperdef{L}{X8203046F7C97EAFE}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{IsUnateBooleanFunction({\mdseries\slshape Func})\index{IsUnateBooleanFunction@\texttt{IsUnateBooleanFunction}}
\label{IsUnateBooleanFunction}
}\hfill{\scriptsize (function)}}\\


  If a Boolean function $f$ is either positive or negative unate in each variable then it is said to be \mbox{\texttt{\mdseries\slshape unate}} (note that some $x_{i}$ may be positive unate and some negative unate to satisfy the definition of
unate function). A Boolean function $f$ is \mbox{\texttt{\mdseries\slshape binate}} if it is not unate (i.e., is neither positive unate nor negative unate in at
least one of its variables).

 All threshold functions are unate. However, the converse is not true, because
there are certain unate functions, that can not be realized by STE \cite{Avedillo1999}. 

 For the Boolean function \texttt{Func} the function \texttt{IsUnateBooleanFunction} returns \texttt{true} if \texttt{Func} is unate and \texttt{false} otherwise. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@f:=[0*Z(2),Z(2)^0,Z(2)^0,Z(2)^0];|
  [ 0, 1, 1, 1 ]
  !gapprompt@gap>| !gapinput@IsUnateBooleanFunction(f);|
  true
  !gapprompt@gap>| !gapinput@f:="1001";|
  "1001"
  !gapprompt@gap>| !gapinput@IsUnateBooleanFunction(f);|
  false
  !gapprompt@gap>| !gapinput@f:=x+y;|
  x+y
  !gapprompt@gap>| !gapinput@IsUnateBooleanFunction(f);|
  Enter the number of variables (n>=2):
  2
  false
  
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{InfluenceOfVariable}}
\logpage{[ 2, 2, 5 ]}\nobreak
\hyperdef{L}{X7D0DEF0B7E9FE027}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{InfluenceOfVariable({\mdseries\slshape Func, Var})\index{InfluenceOfVariable@\texttt{InfluenceOfVariable}}
\label{InfluenceOfVariable}
}\hfill{\scriptsize (function)}}\\


  The influence of a variable $x_i$ measures how many times out of the total existing cases a change on that
variable produces a change on the output of the function.

 For the Boolean function \texttt{Func} and the positive integer \texttt{Var} the function \texttt{InfluenceOfVariable} returns a positive integer - the weighted influence of the variable \texttt{Var} (to obtain integer values we multiply the influence of the variable by $2^n$, where $n$ is the number of variables of \texttt{Func}). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@f:=[0*Z(2),0*Z(2),0*Z(2),0*Z(2),0*Z(2),Z(2)^0,Z(2)^0,0*Z(2)];;|
  !gapprompt@gap>| !gapinput@InfluenceOfVariable(f,1);|
  2
  !gapprompt@gap>| !gapinput@InfluenceOfVariable(f,3);|
  2
  !gapprompt@gap>| !gapinput@f:="00000110";|
  "00000110"
  !gapprompt@gap>| !gapinput@InfluenceOfVariable(f,2);|
  2
  !gapprompt@gap>| !gapinput@f:=x*y+x*z;|
  x*y+x*z
  !gapprompt@gap>| !gapinput@InfluenceOfVariable(f,3);|
  Enter the number of variables (n>=3):
  2
  
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{SelfDualExtensionOfBooleanFunction}}
\logpage{[ 2, 2, 6 ]}\nobreak
\hyperdef{L}{X86C000FE831CFEDE}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{SelfDualExtensionOfBooleanFunction({\mdseries\slshape Func})\index{SelfDualExtensionOfBooleanFunction@\texttt{SelfDualExtensionOfBooleanFunction}}
\label{SelfDualExtensionOfBooleanFunction}
}\hfill{\scriptsize (function)}}\\


  The \mbox{\texttt{\mdseries\slshape self-dual extension}} of a Boolean function $f^{n}:\mathbb{Z}_2^n \to \mathbb{Z}_2$ of $n$ variables is a Boolean function $f^{n+1}:\mathbb{Z}_2^{n+1} \to \mathbb{Z}_2$ of $n+1$ variables defined as 
\[ f^{n+1}(x_1,\ldots,x_n,x_{n+1})=f^{n}(x_1,\ldots,x_n) \quad \textrm{if} \quad
x_{n+1}=0, \]
 
\[ f^{n+1}(x_1,\ldots,x_n,x_{n+1})=1-f^{n}(\overline x_1,\ldots,\overline x_n)
\quad \textrm{if} \quad x_{n+1}=1, \]
 where $\overline x_i = x_i \oplus 1$ is the negation of the $i$-th variable. 

 Every threshold function is unate. However, in \cite{Franco2006} was shown that the unatness in the self-dual space of $n+1$ variables is much stronger condition.

 For the Boolean function \texttt{Func} the function \texttt{SelfDualExtensionOfBooleanFunction} returns the truth vector of the self-dual extension of \texttt{Func}.

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@f:=[0*Z(2),0*Z(2),0*Z(2),Z(2)^0];;|
  !gapprompt@gap>| !gapinput@fsd:=SelfDualExtensionOfBooleanFunction(f);;|
  !gapprompt@gap>| !gapinput@List(fsd,Order);|
  [ 0, 0, 0, 1, 0, 1, 1, 1 ]
  !gapprompt@gap>| !gapinput@f:="0001";;|
  !gapprompt@gap>| !gapinput@fsd:=SelfDualExtensionOfBooleanFunction(f);;|
  !gapprompt@gap>| !gapinput@List(fsd,Order);|
  [ 0, 0, 0, 1, 0, 1, 1, 1 ]
  !gapprompt@gap>| !gapinput@f:=x*y;;|
  !gapprompt@gap>| !gapinput@fsd:=SelfDualExtensionOfBooleanFunction(f);;|
  Enter the number of variables (n>=2):
  !gapprompt@gap>| !gapinput@List(fsd,Order);|
  [ 0, 0, 0, 1, 0, 1, 1, 1 ]
  
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{SplitBooleanFunction}}
\logpage{[ 2, 2, 7 ]}\nobreak
\hyperdef{L}{X7C09D66E84201A77}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{SplitBooleanFunction({\mdseries\slshape Func, Var, Bool})\index{SplitBooleanFunction@\texttt{SplitBooleanFunction}}
\label{SplitBooleanFunction}
}\hfill{\scriptsize (function)}}\\


  The method of splitting a function in terms of a given variable is known as
Shannon decomposition and it was formally introduced in 1938 by Shannon.

 Let $f(x_1,\ldots,x_n)$ be a Boolean function. Decompose $f$ as a disjunction of the following two Boolean functions $f_a$ and $f_b$ defined as: 
\[ \textstyle f_a(x_1,\ldots,x_n)=f(x_1,\ldots,x_{i-1},0,x_{i+1},\ldots,x_n)
\quad \textrm{if} \quad x_i=0, \]
 
\[ f_a(x_1,\ldots,x_n)=0, \quad \textrm{if} \quad x_i=1; \]
 and 
\[ f_b(x_1,\ldots,x_n)= 0 \quad \textrm{if} \quad x_i=0,\quad \]
 
\[ f_b(x_1,\ldots,x_n)=f(x_1,\ldots,x_{i-1},1,x_{i+1},\ldots,x_n) \quad
\textrm{if} \quad x_i=1. \]
 If are intended to use conjunction, we can apply the same equations with 1 for
undetermined outputs instead of 0.

 For the Boolean function \texttt{Func}, a positive integer \texttt{Var} (the number of variable), Boolean variable \texttt{Bool} (\texttt{true} for disjunction and \texttt{false} for conjunction) the function \texttt{SplitBooleanFunction} returns a list with two entries: the truth vectors of the resulting functions. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@f:=[0*Z(2),Z(2)^0,Z(2)^0,0*Z(2)];;|
  !gapprompt@gap>| !gapinput@out:=SplitBooleanFunction(f,1,false);;|
  !gapprompt@gap>| !gapinput@List(out[1],Order);|
  [ 0, 1, 1, 1 ]
  !gapprompt@gap>| !gapinput@List(out[2],Order);|
  [ 1, 1, 1, 0 ]
  !gapprompt@gap>| !gapinput@f:="0110";|
  "0110"
  !gapprompt@gap>| !gapinput@out:=SplitBooleanFunction(f,1,true);;|
  !gapprompt@gap>| !gapinput@List(out[1],Order);|
  [ 0, 1, 0, 0 ]
  !gapprompt@gap>| !gapinput@List(out[2],Order);|
  [ 0, 0, 1, 0 ]
  !gapprompt@gap>| !gapinput@f:=x+y;|
  x+y
  !gapprompt@gap>| !gapinput@out:=SplitBooleanFunction(f,1,true);|
  Enter the number of variables (n>=2):
  2
  [ [ 0, 1, 0, 0 ], [ 0, 0, 1, 0 ] ]
  
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{KernelOfBooleanFunction}}
\logpage{[ 2, 2, 8 ]}\nobreak
\hyperdef{L}{X8108DE5280908841}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{KernelOfBooleanFunction({\mdseries\slshape Func})\index{KernelOfBooleanFunction@\texttt{KernelOfBooleanFunction}}
\label{KernelOfBooleanFunction}
}\hfill{\scriptsize (function)}}\\


  For a Boolean function $f(x_1,\ldots,x_n)$ we define the following two sets (see \cite{GecheBovdi80}): 
\[
f^{-1}(1)=\{ \; \mathbf{x} \in \mathbb{Z}_2^n \; \mid \; f(\mathbf{x})=1 \; \}, \quad \textrm{and} \quad f^{-1}(0)=\{ \; \mathbf{x} \in \mathbb{Z}_2^n \; \mid \; f(\mathbf{x})=0 \; \}.
\]

 The kernel $K(f)$ of the Boolean function $f$ is defined as 
\[ K(f)=f^{-1}(1), \quad \textrm{ if } \quad |f^{-1}(1)| \geq |f^{-1}(0)|; \]
 
\[ K(f)=f^{-1}(0), \quad \textrm{otherwise,} \]
 where $|f^{-1}(i)|$ is the cardinality of the set $f^{-1}(i)$ with $i \in \{0,1\}$. 

 For the Boolean function \texttt{Func} the function \texttt{KernelOfBooleanFunction} returns a list in which the first element of the output list represents the
kernel, and the second element equals either $1$ or $0$. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@f:=[0*Z(2),0*Z(2),0*Z(2),Z(2)^0];|
  [ 0, 0, 0, 1 ]
  !gapprompt@gap>| !gapinput@k:=KernelOfBooleanFunction(f);|
  [ [ [ 1, 1 ] ], 1 ]
  !gapprompt@gap>| !gapinput@f:="0111";|
  "0111"
  !gapprompt@gap>| !gapinput@k:=KernelOfBooleanFunction(f);|
  [ [ [ 0, 0 ] ], 0 ]
  !gapprompt@gap>| !gapinput@z:=Indeterminate(GF(2),"z");|
  z
  !gapprompt@gap>| !gapinput@f:=x*y+z;|
  x*y+z
  !gapprompt@gap>| !gapinput@k:=KernelOfBooleanFunction(f);|
  Enter the number of variables n (n>=3):
  3
  [ [ [ 0, 0, 1 ], [ 0, 1, 1 ], [ 1, 0, 1 ], [ 1, 1, 0 ] ], 1 ]
  
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{ReducedKernelOfBooleanFunction}}
\logpage{[ 2, 2, 9 ]}\nobreak
\hyperdef{L}{X7B1B54877B354F23}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{ReducedKernelOfBooleanFunction({\mdseries\slshape Ker})\index{ReducedKernelOfBooleanFunction@\texttt{ReducedKernelOfBooleanFunction}}
\label{ReducedKernelOfBooleanFunction}
}\hfill{\scriptsize (function)}}\\


  Let $f(x_1,\ldots,x_n)$ be a Boolean function with the kernel $K(f)=\{\;a_1,\ldots,a_m\;\}$, where $m \leq 2^{n-1}$. The reduced kernel $K(f)_i$ of the function $f$ relative to the element $a_i \in K(f)$ is the following set (see \cite{GecheBovdi80}): 
\[ K(f)_i=\big\{\;a_1 \oplus a_i, \; a_2 \oplus a_i,\; \ldots,\; a_m \oplus a_i
\; \big\}, \]
 where $\oplus$ is a component-wise addition of vectors from $K(f)$ over $GF(2)$. 

 The reduced kernel $T(f)$ of $f$ is the following set: 
\[ T(f)=\big\{ \;K(f)_i \;\mid\; i=1,2,\ldots,m \;\big\}. \]
 For the $m \times n$ matrix \texttt{Ker}, which represents the kernel of some Boolean function $f$, the function \texttt{ReducedKernelOfBooleanFunction} returns the reduced kernel $T(f)$ of $f$. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  ## Continuation of Example 2.2.4
  !gapprompt@gap>| !gapinput@rk:=ReducedKernelOfBooleanFunction(k[1]);;|
  !gapprompt@gap>| !gapinput@j:=1;;|
  !gapprompt@gap>| !gapinput@for i in rk do Print(j,".\n"); Display(i); Print("\n"); j:=j+1; od;|
  1.
   . . .
   . 1 .
   1 . .
   1 1 1
  
  2.
   . 1 .
   . . .
   1 1 .
   1 . 1
  
  3.
   1 . .
   1 1 .
   . . .
   . 1 1
  
  4.
   1 1 1
   1 . 1
   . 1 1
   . . .
  
  
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{IsInverseInKernel}}
\logpage{[ 2, 2, 10 ]}\nobreak
\hyperdef{L}{X7B0855E28717AF12}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{IsInverseInKernel({\mdseries\slshape Func})\index{IsInverseInKernel@\texttt{IsInverseInKernel}}
\label{IsInverseInKernel}
}\hfill{\scriptsize (function)}}\\


  Let $f(x_1,\ldots,x_n)$ be a Boolean function with the kernel $K(f)$. The function \texttt{IsInverseInKernel} returns \texttt{true} if there is a pair of additive inverse vectors in $K(f)$ (this means that $f$ is not STE-realizable, see \cite{GecheRobotyshyn83}) or \texttt{false} otherwise. Note that this function also accepts the kernel of the Boolean
function \texttt{Func} as an input. A vector $b \in \mathbb{Z}_2^n$ is called an additive inverse to $a \in \mathbb{Z}_2^n$ if $a \oplus b = 0$. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@f:=x*y+z;|
  x*y+z
  !gapprompt@gap>| !gapinput@k:=KernelOfBooleanFunction(f);;|
  Enter the number of variables n (n>=3):
  3
  !gapprompt@gap>| !gapinput@Display(k[1]);|
   . . 1
   . 1 1
   1 . 1
   1 1 .
  !gapprompt@gap>| !gapinput@IsInverseInKernel(f);|
  Enter the number of variables n (n>=3):
  3
  true
  
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{IsKernelContainingPrecedingVectors}}
\logpage{[ 2, 2, 11 ]}\nobreak
\hyperdef{L}{X83B234DB7F260879}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{IsKernelContainingPrecedingVectors({\mdseries\slshape Func})\index{IsKernelContainingPrecedingVectors@\texttt{IsKernelContainingPrecedingVectors}}
\label{IsKernelContainingPrecedingVectors}
}\hfill{\scriptsize (function)}}\\


  A vector $a=(\alpha_1,\ldots,\alpha_n) \in \mathbb{Z}_2^n$ precedes a vector $b=(\beta_1,\ldots,\beta_n) \in \mathbb{Z}_2^n$ (we denote it as $a \prec b$) if $\alpha_i \leq \beta_i \textrm{ for each } i=1,\ldots, n$. 

 For a given vector $c \in \mathbb{Z}_2^n$ denote $M_c=\{\;a\in \mathbb{Z}_2^n \;\mid\; a \prec c \;\}$. 

 Let $f(x_1,\ldots,x_n)$ be a Boolean function with reduced kernel $T(f)=\{K(f)_j \mid j=1,2,\ldots, m \}$. If $f$ is implemented by a single threshold element (STE), then there exists $j \in \{1,\ldots, m \}$ such that 
\[ \forall a \in K(f)_j \qquad \textrm{holds} \qquad M_a \subseteq K(f)_j. \]
 The function \texttt{IsKernelContainingPrecedingVectors} returns \texttt{false} for a given function \texttt{Func} if $Func$ is not realizable by a single threshold element (see \cite{GecheMulesa2017}). Note that this function also accepts the kernel of the Boolean function \texttt{Func} as an input. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@f:=x*y+z;|
  x*y+z
  !gapprompt@gap>| !gapinput@IsKernelContainingPrecedingVectors(f);|
  Enter the number of variables n (n>=3):
  3
  false
  
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{IsRKernelBiggerOfCombSum}}
\logpage{[ 2, 2, 12 ]}\nobreak
\hyperdef{L}{X7877118A7A9C51CB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{IsRKernelBiggerOfCombSum({\mdseries\slshape Func})\index{IsRKernelBiggerOfCombSum@\texttt{IsRKernelBiggerOfCombSum}}
\label{IsRKernelBiggerOfCombSum}
}\hfill{\scriptsize (function)}}\\


  Let $f(x_1,\ldots,x_n)$ be a Boolean function with reduced kernel $T(f)$. Denote 
\[ k_i^* = \max\big\{ \; \|a\| = \textstyle \sum_{j=1}^m a_j \; \mid \; a = (a_1,
\ldots, a_m) \in T(f) \; \big\}, \quad (i=1,\ldots,n) \]
 and 
\[ k_A^*=\min\big\{\;k_i^* \; \mid \; i=1, 2, \ldots,n \; \big\}. \]
 If $f$ is implemented by a single threshold element (STE), then the following
condition holds: 
\[ |A| \geq \sum_{i=0}^{k_A^*} {{k_A^*}\choose{i}}, \]
 where ${{k_A^*}\choose{i}}$ is the classical binomial coefficient and $|A|$ is the cardinality of $A$. 

 For a given Boolean function \texttt{Func} the function \texttt{IsRKernelBiggerOfCombSum} returns \texttt{false} if this function is not STE-realizable (see \cite{GecheMulesa2017}). Note that this function also accepts the reduced kernel of the Boolean
function \texttt{Func} as an input. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@f:=x+y;|
  x+y
  !gapprompt@gap>| !gapinput@IsRKernelBiggerOfCombSum(f);|
  Enter the number of variables n (n>=2):
  false
  
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{BooleanFunctionBySTE}}
\logpage{[ 2, 2, 13 ]}\nobreak
\hyperdef{L}{X83D3B18486C5D0B7}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{BooleanFunctionBySTE({\mdseries\slshape Func})\index{BooleanFunctionBySTE@\texttt{BooleanFunctionBySTE}}
\label{BooleanFunctionBySTE}
}\hfill{\scriptsize (function)}}\\


  For a given Boolean function \texttt{Func} the function \texttt{BooleanFunctionBySTE} determines whether \texttt{Func} is realizable by a single threshold element (STE). The function returns a
threshold element with integer weights and integer threshold. If \texttt{Func} is not realizable by STE, it returns an empty list []. The realization of the
function \texttt{BooleanFunctionBySTE} is based on algorithms, proposed in \cite{Geche2010}. 
\begin{Verbatim}[commandchars=!@A,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>A !gapinput@f:=[0*Z(2),0*Z(2),0*Z(2),Z(2)^0];A
  [ 0, 0, 0, 1 ]
  !gapprompt@gap>A !gapinput@te:=BooleanFunctionBySTE(f);A
  < threshold element with weight vector [ 1, 2 ] and threshold 3 >
  !gapprompt@gap>A !gapinput@f:="11001000";A
  "11001000"
  !gapprompt@gap>A !gapinput@te:=BooleanFunctionBySTE(f);A
  < threshold element with weight vector [ -1, -4, -2 ] and threshold -2 >
  !gapprompt@gap>A !gapinput@Display(last);A
  Weight vector = [ -1, -4, -2 ], Threshold = -2.
  Threshold Element realizes the function f :
  [ 0, 0, 0 ] || 1
  [ 0, 0, 1 ] || 1
  [ 0, 1, 0 ] || 0
  [ 0, 1, 1 ] || 0
  [ 1, 0, 0 ] || 1
  [ 1, 0, 1 ] || 0
  [ 1, 1, 0 ] || 0
  [ 1, 1, 1 ] || 0
  Sum of Products:[ 0, 1, 4 ]
  !gapprompt@gap>A !gapinput@f:=x+y;A
  x+y
  !gapprompt@gap>A !gapinput@te:=BooleanFunctionBySTE(f);A
  Enter the number of variables n (n>=2):
  2
  [  ]
  
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{PDBooleanFunctionBySTE}}
\logpage{[ 2, 2, 14 ]}\nobreak
\hyperdef{L}{X8451E4EA7F06222F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{PDBooleanFunctionBySTE({\mdseries\slshape Func})\index{PDBooleanFunctionBySTE@\texttt{PDBooleanFunctionBySTE}}
\label{PDBooleanFunctionBySTE}
}\hfill{\scriptsize (function)}}\\


  Let $f(x_1,\ldots,x_n)$ be a partially defined Boolean function. We denote by \texttt{x} the positions in truth vector, where $f$ is undefined. Then $f^{-1}$\texttt{(x)} is the set of Boolean vectors of $n$ variables on which the function is undefined. The sets $f^{-1}(0)$ and $f^{-1}(1)$ are defined in \texttt{KernelOfBooleanFunction} (\ref{KernelOfBooleanFunction}). The function $f$ is called a \mbox{\texttt{\mdseries\slshape threshold function}} if there is an $n$-dimensional real vector $w=(w_1,\ldots,w_n)$ and a real threshold $T$ such that 
\[ a \in f^{-1}(1) \quad \Longrightarrow \quad a\cdot w^T \geq T, \]
 
\[ a \in f^{-1}(0)\quad \Longrightarrow \quad a\cdot w^T < T, \]
 where $a\cdot w^T$ is the classical inner (scalar) product. 

 For the partially defined Boolean function \texttt{Func} (presented as a string, where \texttt{x} presents the undefined values) the function \texttt{PDBooleanFunctionBySTE} returns a threshold element if \texttt{Func} can be realized by STE and empty list otherwise. The realization of the
function \texttt{PDBooleanFunctionBySTE} is based on the algorithm, proposed in \cite{GecheRobotyshyn83}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@f:="1x001x0x";|
  "1x001x0x"
  !gapprompt@gap>| !gapinput@te:=PDBooleanFunctionBySTE(f);|
  < threshold element with weight vector [ -1, -2, -3 ] and threshold -1 >
  !gapprompt@gap>| !gapinput@List(OutputOfThresholdElement(te),Order);|
  [ 1, 0, 0, 0, 1, 0, 0, 0 ]
  
\end{Verbatim}
 }

 }

 
\section{\textcolor{Chapter }{Iterative Training Methods}}\label{thr_iter}
\logpage{[ 2, 3, 0 ]}
\hyperdef{L}{X7D0584857E0D2265}{}
{
  \textsf{Thelma} also provides a few iterative methods for threshold element training. 

\subsection{\textcolor{Chapter }{ThresholdElementTraining}}
\logpage{[ 2, 3, 1 ]}\nobreak
\hyperdef{L}{X83567B7D79958EBF}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{ThresholdElementTraining({\mdseries\slshape ThrEl, Step, Func, Max{\textunderscore}Iter})\index{ThresholdElementTraining@\texttt{ThresholdElementTraining}}
\label{ThresholdElementTraining}
}\hfill{\scriptsize (function)}}\\


  This is a basic iterative method for the perceptron training \cite{Rosenblatt58}. For the threshold element \texttt{ThrEl} (which is an arbitrary threshold element for the first iteration), the
positive integer \texttt{Step} (the value on which we change parameters while training the threshold
element), the Boolean function \texttt{Func} and the positive integer \texttt{Max{\textunderscore}Iter} - the maximal number of iterations, the function \texttt{ThresholdElementTraining} returns a threshold element, realizing \texttt{Func} (if such threshold element exists). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@f:=[0*Z(2),0*Z(2),0*Z(2),Z(2)^0];|
  [ 0, 0, 0, 1 ]
  !gapprompt@gap>| !gapinput@te1:=RandomThresholdElement(2,-2,2);|
  < threshold element with weight vector [ 0, -1 ] and threshold 0 >
  !gapprompt@gap>| !gapinput@OutputOfThresholdElement(te1);|
  [ 1, 0, 1, 0 ]
  !gapprompt@gap>| !gapinput@te2:=ThresholdElementTraining(te1,1,f,100);|
  < threshold element with weight vector [ 2, 1 ] and threshold 3 >
  !gapprompt@gap>| !gapinput@OutputOfThresholdElement(te2);|
  [ 0, 0, 0, 1 ]
  
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{ThresholdElementBatchTraining}}
\logpage{[ 2, 3, 2 ]}\nobreak
\hyperdef{L}{X83CD889E8125E949}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{ThresholdElementBatchTraining({\mdseries\slshape ThrEl, Step, Func, Max{\textunderscore}Iter})\index{ThresholdElementBatchTraining@\texttt{ThresholdElementBatchTraining}}
\label{ThresholdElementBatchTraining}
}\hfill{\scriptsize (function)}}\\


  For the threshold element \texttt{ThrEl} (which is an arbitrary threshold element for the first iteration), the
positive integer \texttt{Step} (the value on which we change parameters while training the threshold
element), the Boolean function \texttt{Func}, and the positive integer \texttt{Max{\textunderscore}Iter} - the maximal number of iterations, the function \texttt{ThresholdElementTraining} returns a threshold element, realizing \texttt{Func} (if such threshold element exists) via batch training. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@f:=[0*Z(2),0*Z(2),0*Z(2),Z(2)^0];|
  [ 0, 0, 0, 1 ]
  !gapprompt@gap>| !gapinput@te1:=RandomThresholdElement(2,-2,2);|
  < threshold element with weight vector [ 0, 2 ] and threshold 2 >
  !gapprompt@gap>| !gapinput@OutputOfThresholdElement(te1);|
  [ 0, 1, 0, 1 ]
  !gapprompt@gap>| !gapinput@te2:=ThresholdElementBatchTraining(te1,1,f,100);|
  < threshold element with weight vector [ 2, 2 ] and threshold 3 >
  !gapprompt@gap>| !gapinput@OutputOfThresholdElement(te2);|
  [ 0, 0, 0, 1 ]
  
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{WinnowAlgorithm}}
\logpage{[ 2, 3, 3 ]}\nobreak
\hyperdef{L}{X81FEA8AF80573A12}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{WinnowAlgorithm({\mdseries\slshape Func, Step, Max{\textunderscore}Iter})\index{WinnowAlgorithm@\texttt{WinnowAlgorithm}}
\label{WinnowAlgorithm}
}\hfill{\scriptsize (function)}}\\


  A Boolean function $f:\mathbb{Z}_2^n \to \mathbb{Z}_2$ which can be presented in the following form: 
\[ f(x_1,\ldots,x_n)=x_{i_1} \vee \cdots \vee x_{i_k}, \qquad (k \leq n) \]
 is called a \mbox{\texttt{\mdseries\slshape monotone disjunction}}, i.e. it is a disjunction in which no variable appears negated. 

 If the given Boolean function $f$ is a monotone disjunction, the \mbox{\texttt{\mdseries\slshape Winnow algorithm}} is more efficient than the classical Perceptron training algorithm \cite{Littlestone88}. 

 For the Boolean function \texttt{Func}, which is a monotone disjunction, \texttt{WinnowAlgorithm} returns either a threshold element realizing \texttt{Func} or [] if \texttt{Func} is not trainable by \texttt{WinnowAlgorithm}. The positive ingetger \texttt{Step} which is not equal to 1 defines the value on which we change parameters while
running the algorithm and the positive integer \texttt{Max{\textunderscore}Iter} defines the maximal number of iterations. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@f:=x*y+x+y;;|
  !gapprompt@gap>| !gapinput@te:=WinnowAlgorithm(f,2,100);|
  Enter the number of variables (n>=2):
  2
  < threshold element with weight vector [ 1, 1 ] and threshold 1 >
  !gapprompt@gap>| !gapinput@OutputOfThresholdElement(te);|
  [ 0, 1, 1, 1 ]
  
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{Winnow2Algorithm}}
\logpage{[ 2, 3, 4 ]}\nobreak
\hyperdef{L}{X85162EF17EE09E50}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{Winnow2Algorithm({\mdseries\slshape Func, Step, Max{\textunderscore}Iter})\index{Winnow2Algorithm@\texttt{Winnow2Algorithm}}
\label{Winnow2Algorithm}
}\hfill{\scriptsize (function)}}\\


  For any $X \subseteq \mathbb{Z}_2^n$ and for any $\delta$ satisfying $0 < \delta \leq 1$ let $F(X,\delta)$ be the class of functions from $X$ to $\mathbb{Z}_2^n$. Assume that $F(X,\delta)$ satisfies the following condition:

 for each $f \in F(X,\delta)$ there exist $\mu_1,\ldots,\mu_n \geq 0$ such that for all $(x_1,\ldots,x_n) \in X$ 
\[ \textstyle \sum_{i=1}^n \mu_i x_i \geq 1, \quad \textrm{if} \quad
f(x_1,\ldots,x_n)=1 \]
 and 
\[ \textstyle \sum_{i=1}^n \mu_i x_i \leq 1, \quad \textrm{if} \quad
f(x_1,\ldots,x_n)=0. \]
 In other words, the inverse images of 0 and 1 are linearly separable with a
minimum separation that depends on $\delta$. \texttt{Winnow2} algorithm is designed for training this class of the Boolean functions \cite{Littlestone88}.

 For the Boolean function \texttt{Func} from the class of Boolean functions which is described above, the function \texttt{Winnow2Algorithm} returns either a threshold element which realizes \texttt{Func} or [] if \texttt{Func} is not trainable by \texttt{Winnow2Algorithm}. The positive integer \texttt{Step} which is not equal to 1 defines the value on which we change parameters while
running the algorithm. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  ## Conjunction can not be trained by Winnow algorithm.
  !gapprompt@gap>| !gapinput@f:=x*y;;|
  !gapprompt@gap>| !gapinput@te:=WinnowAlgorithm(f,2,100);|
  Enter the number of variables (n>=2):
  2
  [  ]
  ## But in the case of Winnow2 we can obtain the desirable result.
  !gapprompt@gap>| !gapinput@te:=Winnow2Algorithm(f,2,100);|
  Enter the number of variables (n>=2):
  2
  < threshold element with weight vector [ 1/2, 1/2 ] and threshold 1 >
  !gapprompt@gap>| !gapinput@OutputOfThresholdElement(te);|
  [ 0, 0, 0, 1 ]
  
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{STESynthesis}}
\logpage{[ 2, 3, 5 ]}\nobreak
\hyperdef{L}{X7C4B705884A78907}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{STESynthesis({\mdseries\slshape Func})\index{STESynthesis@\texttt{STESynthesis}}
\label{STESynthesis}
}\hfill{\scriptsize (function)}}\\


  The function \texttt{STESynthesis} is based on the algorithm proposed in \cite{Dertouzos65}. In each iteration we perturb an $n+1$-dimensional weight-threshold vector in such manner that the distance between
the given vector and a desired weight-threshold vector, if such vector exists,
is reduced. So if the Boolean function \texttt{Func} is STE-realizable, then this procedure will eventually yield an acceptable
weight-threshold vector. Otherwise iteration process will eventually enter a
limit cycle and the execution of \texttt{STE{\textunderscore}Synthesis} will be stopped. 

 For the Boolean function \texttt{Func} the function \texttt{STESynthesis} returns a threshold element if \texttt{Func} is STE-realizable or an empty list otherwise.

 
\begin{Verbatim}[commandchars=!@A,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>A !gapinput@f:=x*y+x+y;;A
  !gapprompt@gap>A !gapinput@te:=STESynthesis(f);A
  Enter the number of variables (n>=2):
  2
  < threshold element with weight vector [ 2, 2 ] and threshold 1 >
  !gapprompt@gap>A !gapinput@Display(last);A
  Weight vector = [ 2, 2 ], Threshold = 1.
  Threshold Element realizes the function f :
  [ 0, 0 ] || 0
  [ 0, 1 ] || 1
  [ 1, 0 ] || 1
  [ 1, 1 ] || 1
  Product of Sums:[ 0 ]
  
\end{Verbatim}
 }

 }

  }

   
\chapter{\textcolor{Chapter }{Networks of Threshold Elements}}\label{thr_networks}
\logpage{[ 3, 0, 0 ]}
\hyperdef{L}{X7BA69E617DE465FE}{}
{
  Not all Boolean functions can be realized by a single threshold element.
However, all of them can be realized by a multi-layered network of threshold
elements, with a number of threshold elements on a first layer and conjunction
or a disjunction on the second layer. In this chapter we will decribe some
functions regarding such networks. 
\section{\textcolor{Chapter }{Basic Operations}}\label{thr_net_basic}
\logpage{[ 3, 1, 0 ]}
\hyperdef{L}{X82EB5BE77F9F686A}{}
{
  In this section we describe some operations, similar to the ones described in
Section \ref{thr_basic}. 

\subsection{\textcolor{Chapter }{NeuralNetwork}}
\logpage{[ 3, 1, 1 ]}\nobreak
\hyperdef{L}{X780C027786A8E34B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{NeuralNetwork({\mdseries\slshape InnerLayer, OuterLayer})\index{NeuralNetwork@\texttt{NeuralNetwork}}
\label{NeuralNetwork}
}\hfill{\scriptsize (function)}}\\


  For the list of threshold elements \texttt{InnerLayer} and the Boolean variable \texttt{OuterLayer}, which can be either \texttt{true} (for disjunction), \texttt{false} (for conjunction), or \texttt{fail} (if there is only one layer) the function \texttt{NeuralNetwork} returns a neural network built from this inputs. 
\begin{Verbatim}[commandchars=!@A,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>A !gapinput@te1:=ThresholdElement([1,1],1);A
  < threshold element with weight vector [ 1, 1 ] and threshold 1 >
  !gapprompt@gap>A !gapinput@te2:=ThresholdElement([-1,-2],-2);A
  < threshold element with weight vector [ -1, -2 ] and threshold -2 >
  !gapprompt@gap>A !gapinput@inner:=[te1,te2];A
  [ < threshold element with weight vector [ 1, 1 ] and threshold 1 >,
    < threshold element with weight vector [ -1, -2 ] and threshold -2 > ]
  !gapprompt@gap>A !gapinput@nn:=NeuralNetwork(inner,false);A
  < neural network with
  2 threshold elements on inner layer and conjunction on outer level >
  !gapprompt@gap>A !gapinput@Display(last);A
  Inner Layer:
  [ [[ 1, 1 ], 1], [[ -1, -2 ], -2] ]
  Outer Layer: conjunction
  Neural Network realizes the function f :
  [ 0, 0 ] || 0
  [ 0, 1 ] || 1
  [ 1, 0 ] || 1
  [ 1, 1 ] || 0
  Sum of Products:[ 1, 2 ]
  
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{IsNeuralNetwork}}
\logpage{[ 3, 1, 2 ]}\nobreak
\hyperdef{L}{X79B24B8F79161064}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{IsNeuralNetwork({\mdseries\slshape Obj})\index{IsNeuralNetwork@\texttt{IsNeuralNetwork}}
\label{IsNeuralNetwork}
}\hfill{\scriptsize (function)}}\\


  For the object \texttt{Obj} the function \texttt{IsNeuralNetwork} returns \texttt{true} if \texttt{Obj} is a neural network (see \texttt{NeuralNetwork} (\ref{NeuralNetwork})), and \texttt{false} otherwise. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  ## Consider the neural network <C>nn</C> from the previous example.
  !gapprompt@gap>| !gapinput@IsNeuralNetwork(nn);|
  true
  
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{OutputOfNeuralNetwork}}
\logpage{[ 3, 1, 3 ]}\nobreak
\hyperdef{L}{X7C93C473784D1676}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{OutputOfNeuralNetwork({\mdseries\slshape NNetwork})\index{OutputOfNeuralNetwork@\texttt{OutputOfNeuralNetwork}}
\label{OutputOfNeuralNetwork}
}\hfill{\scriptsize (function)}}\\


  For the neural network \texttt{NNetwork} the function \texttt{OutputOfNeuralNetwork} returns the truth vector of the Boolean function, realized by \texttt{NNetwork}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@List(OutputOfNeuralNetwork(nn),Order);|
  [ 0, 1, 1, 0 ]
  
\end{Verbatim}
 }

 }

 
\section{\textcolor{Chapter }{Networks of Threshold Elements}}\label{thr_net_net}
\logpage{[ 3, 2, 0 ]}
\hyperdef{L}{X7BA69E617DE465FE}{}
{
  In this section we consider the networks of threshold elements. 

\subsection{\textcolor{Chapter }{BooleanFunctionByNeuralNetwork}}
\logpage{[ 3, 2, 1 ]}\nobreak
\hyperdef{L}{X786FB7237D875561}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{BooleanFunctionByNeuralNetwork({\mdseries\slshape Func})\index{BooleanFunctionByNeuralNetwork@\texttt{BooleanFunctionByNeuralNetwork}}
\label{BooleanFunctionByNeuralNetwork}
}\hfill{\scriptsize (function)}}\\


  For the Boolean function \texttt{Func} the function \texttt{BooleanFunctionByNeuralNetwork} returns a two-layered neural network, which realizes \texttt{Func} (see \texttt{NeuralNetwork} (\ref{NeuralNetwork})). The realization of this function is based on the algorithm proposed in \cite{GecheRobotyshyn83}. 
\begin{Verbatim}[commandchars=!@A,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>A !gapinput@f:=x*y+z;A
  x*y+z
  !gapprompt@gap>A !gapinput@nn:=BooleanFunctionByNeuralNetwork(f);A
  Enter the number of variables n (n>=3):
  < neural network with
  2 threshold elements on inner layer and disjunction on outer level >
  !gapprompt@gap>A !gapinput@Display(last);A
  Inner Layer:
  [ [[ -1, -2, 4 ], 2], [[ 1, 2, -3 ], 3] ]
  Outer Layer: disjunction
  Neural Network realizes the function f :
  [ 0, 0, 0 ] || 0
  [ 0, 0, 1 ] || 1
  [ 0, 1, 0 ] || 0
  [ 0, 1, 1 ] || 1
  [ 1, 0, 0 ] || 0
  [ 1, 0, 1 ] || 1
  [ 1, 1, 0 ] || 1
  [ 1, 1, 1 ] || 0
  Sum of Products:[ 1, 3, 5, 6 ]
  
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{BooleanFunctionByNeuralNetworkDASG}}
\logpage{[ 3, 2, 2 ]}\nobreak
\hyperdef{L}{X7C6E4221828E6609}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{BooleanFunctionByNeuralNetworkDASG({\mdseries\slshape Func})\index{BooleanFunctionByNeuralNetworkDASG@\texttt{BooleanFunctionByNeuralNetworkDASG}}
\label{BooleanFunctionByNeuralNetworkDASG}
}\hfill{\scriptsize (function)}}\\


  For the Boolean function \texttt{Func} the function \texttt{BooleanFunctionByNeuralNetworkDASG} returns a two-layered neural network which realizes \texttt{Func} (see \texttt{NeuralNetwork} (\ref{NeuralNetwork})). The realization of this function is based on decomposition of \texttt{Func} by the non-unate variables with the biggest influence. The DASG algorithm
(DASG - Decomposition Algorithm for Synthesis and Generalization) was proposed
in \cite{Subirats2008}, however we use a slightly modified version of this algorithm. 
\begin{Verbatim}[commandchars=!@C,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>C !gapinput@f:="00000110";C
  "00000110"
  !gapprompt@gap>C !gapinput@nn:=BooleanFunctionByNeuralNetworkDASG(f);;C
  < neural network with
    2 threshold elements on inner layer and conjunction on outer level >
  !gapprompt@gap>C !gapinput@Display(last);C
  Inner Layer:
  [ [[ 1, 4, 2 ], 3], [[ 1, -4, -2 ], -3] ]
  Outer Layer: conjunction
  Neural Network realizes the function f :
  [ 0, 0, 0 ] || 0
  [ 0, 0, 1 ] || 0
  [ 0, 1, 0 ] || 0
  [ 0, 1, 1 ] || 0
  [ 1, 0, 0 ] || 0
  [ 1, 0, 1 ] || 1
  [ 1, 1, 0 ] || 1
  [ 1, 1, 1 ] || 0
  Sum of Products:[ 5, 6 ]
  
  
\end{Verbatim}
 }

 }

  }

  \def\bibname{References\logpage{[ "Bib", 0, 0 ]}
\hyperdef{L}{X7A6F98FD85F02BFE}{}
}

\bibliographystyle{alpha}
\bibliography{thelma}

\addcontentsline{toc}{chapter}{References}

\def\indexname{Index\logpage{[ "Ind", 0, 0 ]}
\hyperdef{L}{X83A0356F839C696F}{}
}

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Index}


\printindex

\newpage
\immediate\write\pagenrlog{["End"], \arabic{page}];}
\immediate\closeout\pagenrlog
\end{document}
